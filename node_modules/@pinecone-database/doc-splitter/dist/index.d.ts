type Metadata = Record<string, unknown>;
interface DocumentInput {
    pageContent: string;
    metadata?: Metadata;
}
export declare class Document implements DocumentInput {
    pageContent: string;
    metadata: Metadata;
    constructor(fields: DocumentInput);
}
interface TextSplitterParams {
    chunkSize: number;
    chunkOverlap: number;
}
export declare abstract class TextSplitter implements TextSplitterParams {
    chunkSize: number;
    chunkOverlap: number;
    constructor(fields?: Partial<TextSplitterParams>);
    abstract splitText(text: string): Promise<string[]>;
    private getNewLinesCount;
    private getLoc;
    private getIntermediateNewLines;
    private createDocumentsFromText;
    createDocuments(texts: string[], metadatas?: Metadata[]): Promise<Document[]>;
    splitDocuments(documents: Document[]): Promise<Document[]>;
    private joinDocs;
    private warnForExcessChunkSize;
    private createDocAndAdjustCurrentDoc;
    mergeSplits(splits: string[], separator: string): string[];
}
interface RecursiveCharacterTextSplitterParams extends TextSplitterParams {
    separators: string[];
}
export declare const SupportedTextSplitterLanguages: readonly ["markdown", "latex", "html"];
export type SupportedTextSplitterLanguage = (typeof SupportedTextSplitterLanguages)[number];
export declare class RecursiveCharacterTextSplitter extends TextSplitter implements RecursiveCharacterTextSplitterParams {
    separators: string[];
    constructor(fields?: Partial<RecursiveCharacterTextSplitterParams>);
    splitText(text: string): Promise<string[]>;
    mergeSplits(splits: string[], separator: string): string[];
    static getSeparatorsForLanguage(language: SupportedTextSplitterLanguage): string[];
}
export type MarkdownTextSplitterParams = TextSplitterParams;
export declare class MarkdownTextSplitter extends RecursiveCharacterTextSplitter implements MarkdownTextSplitterParams {
    constructor(fields?: Partial<MarkdownTextSplitterParams>);
}
export {};
